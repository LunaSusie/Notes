---
title:abp学习笔记-依赖注入
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---


# 依赖注入
## 传统依赖注入
假设有一个`application service`使用一个`repository`去插入一个`entities`到数据库：
```csharp?linenums
public class PersonAppService
{
	private IPersonRepository _personRepository;
	public PersonAppService()
	{
		_personRepository=new PersonRepository();
	}
	public void CreatePerson(string name ,int age)
	{
		var person=new Person{Name=name, Age=age};
		_personRepository.Insert(person);
	}
}
```
* 组件应该依赖接口而不是实现。PersonAppService中的CreatePerson方法依赖于IPersonRepository和PersonRepository的构造函数。
使用工厂模式：
```csharp?linenums
public class PersonAppService
{
	private IPersonRepository _personRepository;
	public PersonAppService()
	{
		_personRepository=PersonRepositoryFactory.Create();    
	}
	public void CreatePerson(string name ,int age)
	{
		var person=new Person{Name=name, Age=age};
		_personRepository.Insert(person);
	}
}
```
* PersonRepositoryFactory是一个创建并返回一个IPersonRepository的静态类。这被称为服务定位器模式。
* PersonAppService依赖于PersonRepositoryFactory。这是更可以接受的，但仍然有一个硬性依赖。
构造函数注入模式：
```csharp?linenums
public class PersonAppService
{
	private IPersonRepository _personRepository;
	public PersonAppService(IPersonRepository personRepository)
	{
		_personRepository=personRepository;   
	}
	public void CreatePerson(string name ,int age)
	{
		var person=new Person{Name=name, Age=age};
		_personRepository.Insert(person);
	}
}
```
* PersonAppService不知道哪些类实现了IPersonRepository以及如何创建它。谁需要使用PersonAppService，首先创建一个IPersonRepository并将其传递给PersonAppService的构造函数：
```csharp?linenums
var repository=new PresonRepository();
var personService=new PersonAppService(repository);
personService.CreatePerson(''Yuns emre",19);
```
* 依赖类可能有其他依赖关系（这里，PersonRepository可能有依赖关系）。
* 构造器注入模式是提供类的依赖关系的完美方式。通过这种方式，您不能在不提供依赖关系的情况下创建类的实例。
属性注入模式：
```csharp?linenums
public class PersonAppService
{
    public ILogger Logger { get; set; }

    private IPersonRepository _personRepository;

    public PersonAppService(IPersonRepository personRepository)
    {
        _personRepository = personRepository;
        Logger = NullLogger.Instance;
    }

    public void CreatePerson(string name, int age)
    {
        Logger.Debug("Inserting a new person to database with name = " + name);
        var person = new Person { Name = name, Age = age };
        _personRepository.Insert(person);
        Logger.Debug("Successfully inserted!");
    }
}
```
* NullLogger.Instance是实现ILogger的单例对象，但实际上什么都不做（不写日志，它用空方法体实现ILogger）。
* 如果在创建PersonAppService对象之后设置Logger，PersonAppService可以写入日志：
```csharp?linenums
var personService = new PersonAppService(new PersonRepository());
personService.Logger = new Log4NetLogger();
personService.CreatePerson("Yunus Emre", 19);
```
* 假设Log4NetLogger使用Log4Net库实现ILogger并写入日志。
* 因此，PersonAppService实际上可以写日志。如果我们不设置记录器，它不会写入日志。
* ILogger是PersonAppService 的可选依赖。
## 依赖注入框架：Castle Windsor 框架
在一个依赖注入框架中，你首先注册你的接口/类到依赖注入框架，然后你可以解析（创建）一个对象。
```csharp?linenums
var container = new WindsorContainer();

container.Register(
        Component.For<IPersonRepository>().ImplementedBy<PersonRepository>().LifestyleTransient(),
        Component.For<IPersonAppService>().ImplementedBy<PersonAppService>().LifestyleTransient()
    );

var personService = container.Resolve<IPersonAppService>();
personService.CreatePerson("Yunus Emre", 19);
```
* 创建了WindsorContainer。然后 用它们的接口注册 PersonRepository和PersonAppService。
* 然后我们要求容器创建一个IPersonAppService。
## abp依赖注入基础结构
### 注册依赖关系
abp有多种依赖注册类注册您的类。通常常规注册类能满足大部分需求。
#### 常规（约定）注册类
ASP.NET Boilerplate按照`约定`自动注册所有的 Repositories，Domain，Application Service，MVC Controllers和Web API Controllers。
例如，您可能有一个IPersonAppService接口和一个实现它的PersonAppService类：
```csharp?linenums
public interface IPersonAppService : IApplicationService
{
    //...
}

public class PersonAppService : IPersonAppService
{
    //...
}
```
* ASP.NET Boilerplate自动注册它，因为它实现了 IApplicationService接口（它只是一个空的接口）。它被注册为瞬态（每个用户创建的实例）。当你往IPersonAppService接口注入（使用构造函数注入）一个类时，PersonAppService对象被创建并自动传入构造函数。
* 命名约定：该例子中的约定是PersonAppService后缀。
* ASP.NET Boilerplate可以按照惯例注册程序集：
```csharp?linenums
IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
```
* Assembly.GetExecutingAssembly（）获取包含此代码的程序集的引用。您可以将其他程序集传递给RegisterAssemblyByConvention方法。
* 您可以通过实现IConventionalRegisterer接口实现自己的常规（约定）注册类，调用 IocManager.AddConventionalRegisterer方法来编写自己的常规（约定）注册 类。你可以添加它在你的模块的预初始化方法。
#### 帮助接口
注册不符合约定的特殊类，abp提供了两个帮助接口：ITransientDependency和ISingletonDependency
```csharp?linenums
public interface IPersonManager
{
    //...
}

public class MyPersonManager : IPersonManager, ISingletonDependency
{
    //...
}
```
* 当需要注入IPersonManager时，使用MyPersonManager类。
* 注意依赖被声明为Singleton。
#### 自定义/直接注册
使用IocManager和Castle Windsor注册依赖关系。
* 使用IocManager
```csharp?linenums
IocManager.Register<IMyService, MyService>(DependencyLifeStyle.Transient);
```
* 使用Castle Windsor API
```csharp?linenums
IocManager.IocContainer.Register(Classes.FromThisAssembly().BasedOn<IMySpecialInterface>().LifestylePerThread().WithServiceSelf());
```


### 解析
#### 构造函数和属性注入
```csharp?linenums
public class PersonAppService
{
    public ILogger Logger { get; set; }

    private IPersonRepository _personRepository;

    public PersonAppService(IPersonRepository personRepository)
    {
        _personRepository = personRepository;
        Logger = NullLogger.Instance;
    }

    public void CreatePerson(string name, int age)
    {
        Logger.Debug("Inserting a new person to database with name = " + name);
        var person = new Person { Name = name, Age = age };
        _personRepository.Insert(person);
        Logger.Debug("Successfully inserted!");
    }
}
```
* IPersonRepository从构造函数注入，ILogger注入公共属性。
* 这是使用DI系统最合适的方式。
#### IIocResolver，IIocManager和IScopedIocResolver
你可能不得不直接解析你的依赖，而不是构造函数和属性注入。
```csharp?linenums
public class MySampleClass : ITransientDependency
{
    private readonly IIocResolver _iocResolver;

    public MySampleClass(IIocResolver iocResolver)
    {
        _iocResolver = iocResolver;
    }

    public void DoIt()
    {
        //Resolving, using and releasing manually
        var personService1 = _iocResolver.Resolve<PersonAppService>();
        personService1.CreatePerson(new CreatePersonInput { Name = "Yunus", Surname = "Emre" });
        _iocResolver.Release(personService1);

        //Resolving and using in a safe way
        using (var personService2 = _iocResolver.ResolveAsDisposable<PersonAppService>())
        {
            personService2.Object.CreatePerson(new CreatePersonInput { Name = "Yunus", Surname = "Emre" });
        }
    }
}
```
* 它构造器注入IIcResolver并用它来解析和释放对象。
* Resolve方法有一些重载可以根据需要使用。
* 释放方法用于释放组件（对象）。如果手动解析对象，调用Release 是 非常重要的。否则，您的应用程序可能会有内存泄漏问题。为了确保释放对象，只要有可能，就使用ResolveAsDisposable（如上例所示）。它会在使用块的末尾自动调用Release。
* IIocResolver（和IIocManager）也有CreateScope扩展方法（在Abp.Dependency命名空间中定义）来安全释放所有已解析的依赖关系。例:
```csharp?linenums
using (var scope = _iocResolver.CreateScope())
{
    var simpleObj1 = scope.Resolve<SimpleService1>();
    var simpleObj2 = scope.Resolve<SimpleService2>();
    //...
}
```
* 范围也可以使用IScopedIocResolver注入。
#### 附加功能
IShouldInitialize接口
有些类需要在第一次使用之前进行初始化。IShouldInitialize有一个Initialize（）方法。如果你实现了它，那么你的Initialize（）方法会在创建对象之后自动调用（在使用之前）。当然，你应该注入/解析对象才能使用这个功能。
### ASP.NET MVC和ASP.NET Web API集成
在ASP.NET MVC应用程序中，它通常是一个 Controller类。我们也可以在控制器中使用构造器注入和属性注入模式。当一个请求来到我们的应用程序，控制器是使用IOC容器创建的，并且所有依赖项都是递归解析的。