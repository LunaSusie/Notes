---
title: JavaScript 轻量级函数式编程
tags:javaScript,函数式
grammar_cjkRuby: true
---
# 为什么使用函数式编程(fp)
* 你不能信任的代码是你不明白的代码。你无法确定代码是否符合你的业务场景。信任代码，是你通过读代码，而不是跑代码，就能理解这段代码是干什么的，而不是停留在它可能是干什么的层面。`函数式编程的目标，就是写出可读性高和可验证的代码。`
## 函数基础
### 数学函数
* 在数学中，函数总是获取一些输入，然后给出一个输出值。在函数式编程中叫"态射"。
### 函数vs程序
* 程序是任意的功能集合，它可以有多个输入，或许没有，它可以由一个输出值，或许没有。
* 函数是接收输入，明确输出。
### 实参和形参
* arguments是你输入的实参。
* parameters是函数中的命名变量，即形参。
### 输入计数（形参计数）
* 一个函数的所“期望”的实参个数是取决于声明的形参。术语：“Arity”。
* js中的输入计数
	* 使用函数的lenth属性。它是只读的，在函数声明时就已确定。
	* 不是所有的参数列表都可以用以上方式获取输入计数。如：foo(x,y=2)，bar(x,...args)，baz({a,b})
	* 每一个函数都有一个arguments对象数组，arguments.lenth可以在函数内部获取输入计数。
	* 对于ES6中的(x,y,z,...args)参数表，ES6会解析获取剩余未命名的参数，放到args数组。args无论是否为空，它永远是一个数组，并且不包含已经定义的x,y,z参数，只会包含超出前三个值得传入参数。
### 实参技巧
* (...arr)不仅可以出现在形参列表，也可以出现在实参列表。在形参列表，它把实参整合，在实参列表，它把实参展开。
### 形参技巧
* 默认值。foo(x=3)，默认值如果没有传入，或者传入undefined，会进行赋值操作。
* es6解构。foo([x,y,...args]=[])，拿出数组的第一个值赋给x，第二个值赋给y，剩下的组成args。
### 随输入而变化的函数
* 判断出入参数的类型判断执行逻辑。
### 函数输出
* 返回单个值，还是多个值，已什么样的形式封装值。
* 提前return，它除了返回值，还可以结束函数的运行，实现流控制。尽量不要使用return流控制，这样会创造更多的隐含意义。
* 未return的输出会产出副作用。
### 高阶函数
* 一个函数接收或者返回一个甚至多个函数，它叫高阶函数。
* return 不是函数返回的唯一方法，也可以直接执行它。
* 把其他函数视为值，是高阶函数，函数编程应该这样写。
### 保持作用域
* 闭包，闭包是可以记录并且访问他作用域外的变量，甚至这个函数在不同的作用域执行。
* 尽量避免使用闭包记录状态的改变。
* 闭包可以记录函数的第一个输入。在连续函数中指定输入，这种技巧在函数式编程中常用，有两种形式：偏函数和柯里化。
* 闭包可以记录函数值。
### 句法（函数名称）
* 函数名称，指定函数名称，能在堆栈轨迹中获得更多信息。
* 函数名称，可以在内部自引用，比如递归。
* IIFE，立即执行函数中，最好给函数一个名称。
* ES6箭头函数（lambada），lambada表达式相比函数，更简洁，用不用取决于你。
### 关于this
* 别用this。
## 管理输入（输入参数）
* 函数的输入管理，就是对一个函数参数改造，指定/合并/分解函数的某几个参数，然后返回一个新函数的过程。
	* 偏函数是预先指定所有被偏应用的实参，产出一个指定等待接收下一个参数的函数。
	* 柯里化是将一个期望接收多个实参的函数拆解为连续的链式调用，每个链式接收一个参数并返回另一个接收下一个实参的函数。
	* 柯里化可以还原为与原函数相识的函数。
	* 返回只接收原函数第一个参数的函数。
	* 返回接收一个反转原函数参数顺序的函数。
	* Certain API 禁止直接给方法传值，而要求我们传入一个函数，就算这个函数只是返回一个值。
	* 参数顺序，通过对象指定参数，可以忽略参数的输入顺序，以k:v格式设置参数值。
	* 参数扩展。分为数组扩展和对象扩展，把参数格式（数组或者对象）解构或者转化为函数期望的格式。
	* 无参风格，缩减参数个数最终会变成无参风格，这样等于一个函数的全部参数都已经确定完毕，直接调用即可。
## 组合函数
* 函数组合是一种定义函数的模式，它能将一个函数调用的输出路由到另一个函数的调用上，然后一直进行下去。
* JS 函数只能返回单个值，这个模式本质上要求所有组合中的函数（可能第一个调用的函数除外）是一元的，当前函数从上一个函数输出中只接收一个输入。
* 组合函数让我们更关注是什么，而不是做什么。
* 一般组合函数的执行顺序是反序的。你可以用翻转函数参数对他进行进一步改造。
* 任意数目函数的组合的通用可视化数据流表示。
* reduce(..)方式实现函数的组合。
* 通过组合函数可以实现抽象。
## 减少副作用
* 假如一棵树在森林里倒下而没有人在附近听见，它有没有发出声音？
	* 我所得到的是：无论是否产生声音，如果我们从不创造一个当树落下时周围没有人的情景会更好一些。当树落下时，我们总是会听到声音。
	* 减少副作用的目的并不是他们在程序中不能被观察到，而是设计一个程序，让副作用尽可能的少
* 副作用对代码的可读性和质量都有害，因为它们使您的代码难以理解。
* 输出和状态的变化，是最常被引用的副作用的表现，另一个有损可读性的实践是一些被认为的侧因。
 * 幂等是通过本质上创建仅有一次的操作来限制副作用的一种策略。
	* 从数学的角度来看，幂等指的是在第一次调用后，如果你将该输出一次又一次地输入到操作中，其输出永远不会改变的操作。
	* 幂等的面向程序的定义也是类似的，但不太正式。编程中的幂等仅仅是 f(x); 的结果与 f(x); f(x) 相同而不是要求 f(x) === f(f(x))。换句话说，之后每一次调用 f(x) 的结果和第一次调用 f(x) 的结果没有任何改变。
* 避免副作用的最优方法是使用纯函数。
* 引用透明更近一步的状态是 —— 更多的是一种脑力运动而不是文字行为 —— 纯函数的调用是可以用它的输出来代替，并且程序的行为不会被改变。
* 纯函数给定相同输入时总返回相同输出，并且没有副作用。
* 重构纯函数是首选，无法重构就封装副作用。
## 值不可变性
* 值的不可变性并不是不改变值。它是指在程序状态改变时，不直接修改当前数据，而是创建并追踪一个新数据。
* const 和值的不可变性声明无关，而且使用它所带来的困惑似乎比它解决的问题还要大。
* 内置的 Object.freeze(..) 方法提供了顶层值的不可变性设定。
* 对于程序中性能敏感的部分，或者变化频繁发生的地方，处于对计算和存储空间的考量，每次都创建新的数据或对象（特别是在数组或对象包含很多数据时）是非常不可取的。遇到这种情况，通过类似 Immutable.js 的库使用不可变数据结构或许是个很棒的主意。
* 值不变在代码可读性上的意义，不在于不改变数据，而在于以不可变的眼光看待数据这样的约束。
## 闭包vs对象（这一章有一些不可描述）
* 闭包和对象很相像，可以实现互相转化。
* 这两种形式都有典型的可变行为。
* 同构是双映（双向）态射的特殊案例，它需要映射不仅仅必须可以从任意一边完成，而且在任一方式下反应完全一致。闭包和对象是状态的同构表示（及其相关功能）
* 同根异枝（不同点）
	* 闭包的结构不是可变的。对象默认是完全可变的。
	* 闭包通过词法作用域提供“私有”状态。 对象将一切做为公共属性暴露。
	* 从实现的角度看，对象有一个比闭包有利的原因，那就是 JavaScript 对象通常在内存和甚至计算角度是更加轻量的。
## 列表操作
* map(..)，转换列表项的值到新列表。
* filter(..)，选择或过滤掉列表项的值到新数组。
* reduce(..)，合并列表中的值，并且产生一个其他的值（经常但不总是非列表的值）。
* 其他一些非常有用的处理列表的高级操作：unique(..)、flatten(..) 和 merge(..)。