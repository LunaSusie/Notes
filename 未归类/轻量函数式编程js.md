---
title: JavaScript 轻量级函数式编程
tags:javaScript,函数式
grammar_cjkRuby: true
---
# 为什么使用函数式编程(fp)
* 你不能信任的代码是你不明白的代码。你无法确定代码是否符合你的业务场景。信任代码，是你通过读代码，而不是跑代码，就能理解这段代码是干什么的，而不是停留在它可能是干什么的层面。`函数式编程的目标，就是写出可读性高和可验证的代码。`
## 函数基础
### 数学函数
* 在数学中，函数总是获取一些输入，然后给出一个输出值。在函数式编程中叫"态射"。
### 函数vs程序
* 程序是任意的功能集合，它可以有多个输入，或许没有，它可以由一个输出值，或许没有。
* 函数是接收输入，明确输出。
### 实参和形参
* arguments是你输入的实参。
* parameters是函数中的命名变量，即形参。
### 输入计数（形参计数）
* 一个函数的所“期望”的实参个数是取决于声明的形参。术语：“Arity”。
* js中的输入计数
	* 使用函数的lenth属性。它是只读的，在函数声明时就已确定。
	* 不是所有的参数列表都可以用以上方式获取输入计数。如：foo(x,y=2)，bar(x,...args)，baz({a,b})
	* 每一个函数都有一个arguments对象数组，arguments.lenth可以在函数内部获取输入计数。
	* 对于ES6中的(x,y,z,...args)参数表，ES6会解析获取剩余未命名的参数，放到args数组。args无论是否为空，它永远是一个数组，并且不包含已经定义的x,y,z参数，只会包含超出前三个值得传入参数。
### 实参技巧
* (...arr)不仅可以出现在形参列表，也可以出现在实参列表。在形参列表，它把实参整合，在实参列表，它把实参展开。
### 形参技巧
* 默认值。foo(x=3)，默认值如果没有传入，或者传入undefined，会进行赋值操作。
* es6解构。foo([x,y,...args]=[])，拿出数组的第一个值赋给x，第二个值赋给y，剩下的组成args。
### 随输入而变化的函数
* 判断出入参数的类型判断执行逻辑。
### 函数输出
* 返回单个值，还是多个值，已什么样的形式封装值。
* 提前return，它除了返回值，还可以结束函数的运行，实现流控制。尽量不要使用return流控制，这样会创造更多的隐含意义。
* 未return的输出会产出副作用。
### 高阶函数
* 一个函数接收或者返回一个甚至多个函数，它叫高阶函数。
* return 不是函数返回的唯一方法，也可以直接执行它。
* 把其他函数视为值，是高阶函数，函数编程应该这样写。
### 保持作用域
* 闭包，闭包是可以记录并且访问他作用域外的变量，甚至这个函数在不同的作用域执行。
* 尽量避免使用闭包记录状态的改变。
* 闭包可以记录函数的第一个输入。在连续函数中指定输入，这种技巧在函数式编程中常用，有两种形式：偏函数和柯里化。
* 闭包可以记录函数值。
### 句法（函数名称）
* 函数名称，指定函数名称，能在堆栈轨迹中获得更多信息。
* 函数名称，可以在内部自引用，比如递归。
* IIFE，立即执行函数中，最好给函数一个名称。
* ES6箭头函数（lambada），lambada表达式相比函数，更简洁，用不用取决于你。
### 关于this
* 别用this。
## 管理输入
* 一个函数如果有多个形参，一次性传入所有实参，还是一次传递一个参数。取决于你的场景。
* 函数式编程中实现稍后传参有两种方式。偏函数和柯里化。
* 通过闭包返回一个函数是函数式编程基本方式。
* 偏函数，减少函数参数个数的过程。
* 反转函数的顺序。
* 右偏函数，指定函数的参数从右边开始。
* 柯里化，是将一个期望接收多个实参的函数拆解为连续的链式调用，每个链式接收一个参数并返回另一个接收下一个实参的函数。
* 柯里化强调一次只传入一个实参，形成另一个特性更强的函数，之后我们可以指定使用哪个新函数。（柯里化的层次，第二个参数）
* 偏函数是预先指定所有被偏应用的实参，产出一个指定等待接收下一个参数的函数。
* 柯里化风格（sum(1)(2)(3)），偏应用风格（partial(sum,1,2)(3)）
* 松散柯里化，一次指定多个参数。严格柯里化不支持多参数，只能一个一个设置。
* 反柯里化，柯里化的函数可以可以还原成和柯里化前相识的函数。
* 只接收一个实参的函数。
* 接收一个实参，并返回的函数。
* Certain API 禁止直接给方法传值，而要求我们传入一个函数，就算这个函数只是返回一个值。
* 扩展参数。将一个数组扩展成原函数期望的参数格式。spreadArgs(..)函数
* 参数顺序。命名参数，对象解构。
* 属性扩展。将一个对象扩展成原函数期望的参数格式。像之前的 spreadArgs(..) 实用函数一样，我们也可以定义一个 spreadArgProps(..) 辅助函数，它接收对象实参的 key: value 键值对，并将其 “扩展” 成独立实参。不过，对象属性的顺序是不太明确且不可靠的。探知函数形参顺序的技巧，JavaScript 的函数对象上有一个 .toString() 方法，它返回函数代码的字符串形式，其中包括函数声明的签名。
* 无参风格。通过移除不必要的形参-实参映射来减少视觉上的干扰。参数通过闭包传递。